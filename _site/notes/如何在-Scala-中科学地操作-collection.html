<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>如何在 scala 中科学地操作 collection</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@HeiswayiNrird" /><meta name="twitter:title" content="如何在 scala 中科学地操作 collection" /><meta name="twitter:description" content="在日常项目开发中，我们几乎都会用到Scala中的集合以及一些集合操作。由于 Scala 中的集合操作灵活多变，对于刚接触Scala的开发者，在选用何种集合以及使用何种集合操作就显得不那么合理了，虽然大部分时候都可以解决问题，但是有时候并没有选择最优的方式。科学合理地操作Scala中的集合可以使我们的代码变得更加简洁和高效。"><meta name="description" content="在日常项目开发中，我们几乎都会用到Scala中的集合以及一些集合操作。由于 Scala 中的集合操作灵活多变，对于刚接触Scala的开发者，在选用何种集合以及使用何种集合操作就显得不那么合理了，虽然大部分时候都可以解决问题，但是有时候并没有选择最优的方式。科学合理地操作Scala中的集合可以使我们的代码变得更加简..."> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?2db4617ae1e0a3147b448ffe9d4a4c26"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><style> /* latin-ext */ @font-face { font-family: 'Karla'; font-style: normal; font-weight: 400; src: local('Karla'), local('Karla-Regular'), url(https://fonts.gstatic.com/s/karla/v5/S1bXQ0LrY7AzefpgNae9sYDGDUGfDkXyfkzVDelzfFk.woff2) format('woff2'); unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF; } /* latin */ @font-face { font-family: 'Karla'; font-style: normal; font-weight: 400; src: local('Karla'), local('Karla-Regular'), url(https://fonts.gstatic.com/s/karla/v5/JaMH4jmmzP070-OYo03anaCWcynf_cDxXwCLxiixG1c.woff2) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215; }</style><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/notes/%E5%A6%82%E4%BD%95%E5%9C%A8-Scala-%E4%B8%AD%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%93%8D%E4%BD%9C-collection"><link rel="alternate" type="application/atom+xml" title="ShawDubie" href="/feed.xml" /> <!-- 多说公共JS代码 start (一个网页只需插入一次) --> <script type="text/javascript"> var duoshuoQuery = {short_name:"shawdubie"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); </script> <!-- 多说公共JS代码 end --></head><body><aside class="logo"> <a href="/"> <img src="../assets/img/shaw.jpeg" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>如何在 scala 中科学地操作 collection</h1><time>March 10, 2017</time></div><div class="divider"></div><p>在日常项目开发中，我们几乎都会用到Scala中的集合以及一些集合操作。由于 Scala 中的集合操作灵活多变，对于刚接触Scala的开发者，在选用何种集合以及使用何种集合操作就显得不那么合理了，虽然大部分时候都可以解决问题，但是有时候并没有选择最优的方式。科学合理地操作Scala中的集合可以使我们的代码变得更加简洁和高效。</p><h2 id="mutable-和-immutable-集合">Mutable 和 Immutable 集合</h2><p>Scala 集合类系统地区分了可变的和不可变的集合。</p><h3 id="scalacollection-包中所有的集合类">scala.collection 包中所有的集合类</h3><p><img src="../assets/img/collections.png" alt="Image of collections" /></p><h3 id="scalacollectionmutable-中的所有集合类">scala.collection.mutable 中的所有集合类</h3><p><code class="highlighter-rouge">可变集合</code>，顾名思义，意味着你可以修改，移除或者添加一个元素。</p><p><img src="../assets/img/collections.mutable.png" alt="Image of immutatble collection" /></p><h3 id="scalacollectionimmutable-中的所有集合类">scala.collection.immutable 中的所有集合类</h3><p><code class="highlighter-rouge">不可变集合</code>，相比<code class="highlighter-rouge">可变集合</code>，<code class="highlighter-rouge">不可变集合</code>永远不会被改变，但是你仍然可以像<code class="highlighter-rouge">可变集合</code>那样操作（修改，添加，删除某个集合元素）<code class="highlighter-rouge">不可变集合</code>，只是这些操作在每一种情况下都是返回一个新的集合，同时，原来的集合不会发生改变，由于此特性，<code class="highlighter-rouge">不可变集合</code>也是线程安全的，Scala在默认情况下采用的是<code class="highlighter-rouge">不可变集合</code>。所以在使用上，优先使用<code class="highlighter-rouge">不可变集合</code>。<code class="highlighter-rouge">不可变集</code>合适用于大多数情况。</p><p><img src="../assets/img/collections.immutable.png" alt="Image of mutable collection" /></p><h2 id="不同集合的使用场景">不同集合的使用场景</h2><p>其中常用的集合有三种：<code class="highlighter-rouge">List</code>，<code class="highlighter-rouge">Set</code>，<code class="highlighter-rouge">Map</code>。</p><h3 id="列表-list">列表 List</h3><p><code class="highlighter-rouge">List</code> 继承至 <code class="highlighter-rouge">Seq</code>，集合中的元素是可以重复的。</p><p>e.g.</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div><p>所以当集合内的元素是可重复的时候，可以选择 <code class="highlighter-rouge">List</code> 或者 <code class="highlighter-rouge">Seq</code>。</p><h3 id="集-set">集 Set</h3><p><code class="highlighter-rouge">Set</code> 中的元素是不可重复的。</p><p>e.g.</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div><p>所以当集合内的元素是不可重复的时候，选择 <code class="highlighter-rouge">Set</code>。</p><h3 id="映射-map">映射 Map</h3><p><code class="highlighter-rouge">Map</code> 中的元素呈现 <code class="highlighter-rouge">key -&gt; value</code> 的形式，其中第一个参数是映射的键，第二个参数是映射的值。且Map中每一个元素的键是唯一的。</p><p>e.g.</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="o">)</span>
<span class="n">m</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div><p>所以当集合中的元素是 <code class="highlighter-rouge">key -&gt; value</code> 的形式且每个元素的键不重复的时候，选择 <code class="highlighter-rouge">Map</code>。</p><h2 id="集合中方法的使用">集合中方法的使用</h2><h3 id="各集合操作之间的比较">各集合操作之间的比较</h3><p>在开始介绍不同方法的使用场景之前，我们先对比一下不同方法操作同一集合所产出的结果有何异同。</p><ul><li><code class="highlighter-rouge">map</code>、<code class="highlighter-rouge">filter</code>、<code class="highlighter-rouge">collect</code> 的比较</li></ul><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">//定义一个列表
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="c1">//map操作
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">//filter操作
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="c1">//collect操作
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">collect</span> <span class="o">{</span><span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">}</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</code></pre></div><p>通过以上结果对比我们可以看到：</p><p><code class="highlighter-rouge">map</code> 操作得到的集合，除了元素个数和原集合一样，其他都不一样。</p><p><code class="highlighter-rouge">filter</code> 操作得到的集合是原集合的子集。</p><p><code class="highlighter-rouge">collect</code> 操作得到的集合虽然和原集合不一样，但是仔细观察，可以看到 <code class="highlighter-rouge">collect</code> 操作得到的结果是 <code class="highlighter-rouge">map</code> 操作得到结果的子集，而且元素的个数和 <code class="highlighter-rouge">filter</code> 操作得到的集合元素个数相同。</p><ul><li><code class="highlighter-rouge">flatten</code> 和 <code class="highlighter-rouge">flatMap</code> 的比较</li></ul><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="c1">//定义一个列表
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">))</span>
<span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">))</span>

<span class="c1">//flatten操作
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">flatten</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>

<span class="c1">//flatMap操作
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">)</span>
</code></pre></div><p>通过以上结果我们可以看到，<code class="highlighter-rouge">flatten</code> 和 <code class="highlighter-rouge">flatMap</code> 都可可以将嵌套结构扁平化为一个层次的集合，但是：</p><p><code class="highlighter-rouge">flatten</code> 仅仅是将嵌套结构扁平化了，并没有改变原来集合内层列表中元素的值。</p><p><code class="highlighter-rouge">flatMap</code> 不仅将嵌套结构扁平化了，而且改变了原来集合内层列表中元素的值，其实 <code class="highlighter-rouge">flatMap</code> 就是在 <code class="highlighter-rouge">flatten</code> 之后再做一个 <code class="highlighter-rouge">map</code> 操作。</p><p>补充：以上操作返回的都是一个批量的结果，如果要查找某一特定元素，则可以采用类比的方法：</p><p><code class="highlighter-rouge">filter</code> -&gt; <code class="highlighter-rouge">find</code></p><p><code class="highlighter-rouge">collect</code> -&gt; <code class="highlighter-rouge">collectFirst</code></p><h3 id="不同方法的使用场景">不同方法的使用场景</h3><p>通过以上对比，我们对集合中常用方法的操作结果有了一个大致的认识，接下来我们看看在不同场景下如何科学地选择相应的集合操作。</p><p>我们先定义一些将要在后面场景中使用的数据结构：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Student</span><span class="o">(</span>
  <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="n">sex</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">)</span>
<span class="k">val</span> <span class="n">jilen</span> <span class="k">=</span> <span class="nc">Student</span><span class="o">(</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">"Jilen"</span><span class="o">,</span>
  <span class="n">age</span> <span class="k">=</span> <span class="mi">30</span><span class="o">,</span>
  <span class="n">sex</span> <span class="k">=</span> <span class="s">"m"</span>
<span class="o">)</span>
<span class="k">val</span> <span class="n">shaw</span> <span class="k">=</span> <span class="nc">Student</span><span class="o">(</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">"Shaw"</span><span class="o">,</span>
  <span class="n">age</span> <span class="k">=</span> <span class="mi">18</span><span class="o">,</span>
  <span class="n">sex</span> <span class="k">=</span> <span class="s">"m"</span>
<span class="o">)</span>
<span class="k">val</span> <span class="n">yison</span> <span class="k">=</span> <span class="nc">Student</span><span class="o">(</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">"Yison"</span><span class="o">,</span>
  <span class="n">age</span> <span class="k">=</span> <span class="mi">40</span><span class="o">,</span>
  <span class="n">sex</span> <span class="k">=</span> <span class="s">"f"</span>
<span class="o">)</span>
<span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">jilen</span><span class="o">,</span> <span class="n">shaw</span><span class="o">,</span> <span class="n">yison</span><span class="o">)</span>
<span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="n">m</span><span class="o">),</span> <span class="nc">Student</span><span class="o">(</span><span class="nc">Shaw</span><span class="o">,</span><span class="mi">18</span><span class="o">,</span><span class="n">m</span><span class="o">),</span> <span class="nc">Student</span><span class="o">(</span><span class="nc">Yison</span><span class="o">,</span><span class="mi">40</span><span class="o">,</span><span class="n">f</span><span class="o">))</span>
</code></pre></div><p>如上，我们定义了一个学生组成的列表。</p><h4 id="场景一我们要得到这些学生姓名所组成的列表">场景一：我们要得到这些学生姓名所组成的列表</h4><p>分析：学生姓名所组成的列表和原列表（学生列表）是不同的，是一个全新的列表，所以这里选用 <code class="highlighter-rouge">map</code></p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">nameList</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
<span class="n">nameList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span> <span class="nc">Shaw</span><span class="o">,</span> <span class="nc">Yison</span><span class="o">)</span>
</code></pre></div><p><code class="highlighter-rouge">map</code> 是对集合中的每个元素应用一个函数，返回应用后的元素所组成的集合，通常情况下，map所返回的集合和原集合是是不同类型的集合，也就是一个全新的集合。</p><h4 id="场景二我们要得到所有性别是男m的学生所组成的列表">场景二：我们要得到所有性别是男（m）的学生所组成的列表</h4><p>分析：得到的列表还是学生列表，并且该列表是原列表的子集，因为有一个附加条件：男性学生，所以这里选用 <code class="highlighter-rouge">filter</code></p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">maleList</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="s">"m"</span><span class="o">)</span>
<span class="n">maleList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="n">m</span><span class="o">),</span> <span class="nc">Student</span><span class="o">(</span><span class="nc">Shaw</span><span class="o">,</span><span class="mi">18</span><span class="o">,</span><span class="n">m</span><span class="o">))</span>
</code></pre></div><p><code class="highlighter-rouge">filter</code> 一般用于移除集合中不满足条件的元素，返回满足条件的元素所组成的集合。 当然，这里用 <code class="highlighter-rouge">collect</code> 也可以解决问题：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">maleList</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">collect</span><span class="o">{</span><span class="k">case</span> <span class="n">s</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="s">"m"</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">}</span>
<span class="n">maleList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="n">m</span><span class="o">),</span> <span class="nc">Student</span><span class="o">(</span><span class="nc">Shaw</span><span class="o">,</span><span class="mi">18</span><span class="o">,</span><span class="n">m</span><span class="o">))</span>
</code></pre></div><p>但是对比一下，可以发现filter更加简洁。</p><h4 id="场景三-我们要得到男学生姓名所组成的列表">场景三： 我们要得到男学生姓名所组成的列表</h4><p>分析：要得到男学生姓名，我们首先要得到男学生，然后再去获取这些学生的姓名，所以我们很容易采用：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">maleNameList</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="s">"m"</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
<span class="n">maleNameList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span> <span class="nc">Shaw</span><span class="o">)</span>
</code></pre></div><p>但是通过我们在之前<code class="highlighter-rouge">各集合操作之间的比较</code>中所得出的结论，由于男学生姓名列表是一个和原列表（学生列表）完全不同的，并且该列表是学生姓名列表的子集，所以我们可以采用 <code class="highlighter-rouge">collect</code>：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">maleNameList</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">collect</span><span class="o">{</span><span class="k">case</span> <span class="n">s</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="s">"m"</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="o">}</span>
<span class="n">maleNameList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span> <span class="nc">Shaw</span><span class="o">)</span>
</code></pre></div><p>得到的结果和上面操作的结果一样。</p><p><code class="highlighter-rouge">collect</code> 接受的是一个偏函数，对集合中每个元素应用该函数，返回应用后的元素所组成的列表，可以将 <code class="highlighter-rouge">collect</code> 看作是先做 <code class="highlighter-rouge">filter</code> 操作再做 <code class="highlighter-rouge">map</code> 操作：</p><p>场景二中的 <code class="highlighter-rouge">collect</code> 操作可以看作是：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">l</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="s">"m"</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">)</span>
<span class="nc">List</span><span class="o">[</span><span class="kt">Student</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="n">m</span><span class="o">),</span> <span class="nc">Student</span><span class="o">(</span><span class="nc">Shaw</span><span class="o">,</span><span class="mi">18</span><span class="o">,</span><span class="n">m</span><span class="o">))</span>
</code></pre></div><h3 id="其他常用方法">其他常用方法</h3><h4 id="场景四现在我们要得到每个学生在列表中的位置以方便给他们编号">场景四：现在我们要得到每个学生在列表中的位置以方便给他们编号</h4><p>分析：我们可以采用 <code class="highlighter-rouge">学生 -&gt; 编号</code> 的形式来组织学生与编号之前的关系，这里我们可以采用 <code class="highlighter-rouge">zipWithIndex</code>：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">l</span><span class="o">.</span><span class="n">zipWithIndex</span>
<span class="nc">List</span><span class="o">[(</span><span class="kt">Student</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="n">m</span><span class="o">),</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Shaw</span><span class="o">,</span><span class="mi">18</span><span class="o">,</span><span class="n">m</span><span class="o">),</span><span class="mi">1</span><span class="o">),(</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Yison</span><span class="o">,</span><span class="mi">40</span><span class="o">,</span><span class="n">f</span><span class="o">),</span><span class="mi">2</span><span class="o">))</span>
</code></pre></div><p><code class="highlighter-rouge">zipWithIndex</code> 将可以将集合内的元素与该元素在集合中的位置组合在一起，其实就是将集合内的元素与该元素的位置组成了一个元组，元组的第二个值是元素在集合中所处的位置。</p><h4 id="场景五现在要将男学生和女学生分组男学生组成一个集合女学生组成一个集合">场景五：现在要将男学生和女学生分组，男学生组成一个集合，女学生组成一个集合</h4><p>分析：根据场景的描述，新集合内的元素应该是：<code class="highlighter-rouge">sex -&gt; List[Student]</code>的形式，这里我们可以采用：<code class="highlighter-rouge">groupBy</code>：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">group</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">sex</span><span class="o">)</span>
<span class="n">group</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">List</span><span class="o">[</span><span class="kt">Student</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Jilen</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="n">m</span><span class="o">),</span> <span class="nc">Student</span><span class="o">(</span><span class="nc">Shaw</span><span class="o">,</span><span class="mi">18</span><span class="o">,</span><span class="n">m</span><span class="o">)),</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Student</span><span class="o">(</span><span class="nc">Yison</span><span class="o">,</span><span class="mi">40</span><span class="o">,</span><span class="n">f</span><span class="o">)))</span>
</code></pre></div><p><code class="highlighter-rouge">groupBy</code> 就是对集合按照特定的要求进行分组，返回一个 <code class="highlighter-rouge">Map</code>类型。</p><h2 id="延伸阅读">延伸阅读</h2><p><a href="https://pavelfatin.com/scala-collections-tips-and-tricks/">Scala Collections Tips and Tricks</a></p><p><a href="https://twitter.github.io/scala_school/zh_cn/collections.html">集合</a></p></article><div class="page-navigation"> <a class="next" href="/notes/How-to-use-algebraic-data-type-in-development" title="NEXT: 如何在 Scala 中利用 ADT 良好地组织业务">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="/" title="Back to Homepage">Home</a> <span> &middot; </span> <a class="prev" href="/notes/mapAndFlatMap" title="PREV: Scala中的map、flatMap">&gt;&gt;</a></div></main><div class="footer"> <!-- 多说评论框 start --><div class="ds-thread" data-thread-key="如何在 scala 中科学地操作 collection" data-title="如何在 scala 中科学地操作 collection" data-url="http://shawdubie.com/notes/如何在 scala 中科学地操作 collection"></div><!-- 多说评论框 end --> · <span class="block">Made with &hearts; using <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> &amp; <a href="https://github.com/heiswayi/the-plain" title="The Plain theme by Heiswayi Nrird" target="_blank">The Plain</a> &middot; &lt;/&gt; on <a href="https://github.com/Shonrain" title="Hosted on GitHub" target="_blank">GitHub</a></span> <span class="block">&copy; 2017 ShawDubie</span></div></body></html>