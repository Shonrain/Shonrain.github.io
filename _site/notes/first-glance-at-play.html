<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Play! Framework 系列（一）：初探 play 框架</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@HeiswayiNrird" /><meta name="twitter:title" content="Play! Framework 系列（一）：初探 play 框架" /><meta name="twitter:description" content="Play! 是一种高效率的 Java 和 Scala Web 应用程序框架，它集成了现代 Web 应用程序开发所需的组件和 API。本文将介绍一下 Play! 的基本性质以及利用该框架开发 Web 程序的优势。"><meta name="description" content="Play! 是一种高效率的 Java 和 Scala Web 应用程序框架，它集成了现代 Web 应用程序开发所需的组件和 API。本文将介绍一下 Play! 的基本性质以及利用该框架开发 Web 程序的优势。"> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?2db4617ae1e0a3147b448ffe9d4a4c26"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><style> /* latin-ext */ @font-face { font-family: 'Karla'; font-style: normal; font-weight: 400; src: local('Karla'), local('Karla-Regular'), url(https://fonts.gstatic.com/s/karla/v5/S1bXQ0LrY7AzefpgNae9sYDGDUGfDkXyfkzVDelzfFk.woff2) format('woff2'); unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF; } /* latin */ @font-face { font-family: 'Karla'; font-style: normal; font-weight: 400; src: local('Karla'), local('Karla-Regular'), url(https://fonts.gstatic.com/s/karla/v5/JaMH4jmmzP070-OYo03anaCWcynf_cDxXwCLxiixG1c.woff2) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215; }</style><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/notes/first-glance-at-play"><link rel="alternate" type="application/atom+xml" title="ShawDubie" href="/feed.xml" /> <!-- 多说公共JS代码 start (一个网页只需插入一次) --> <script type="text/javascript"> var duoshuoQuery = {short_name:"shawdubie"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); </script> <!-- 多说公共JS代码 end --></head><body><aside class="logo"> <a href="/"> <img src="../assets/img/shaw.jpeg" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>Play! Framework 系列（一）：初探 play 框架</h1><time>July 10, 2017</time></div><div class="divider"></div><p><code class="highlighter-rouge">Play!</code> 是一种高效率的 Java 和 Scala Web 应用程序框架，它集成了现代 Web 应用程序开发所需的组件和 API。本文将介绍一下 <code class="highlighter-rouge">Play!</code> 的基本性质以及利用该框架开发 Web 程序的优势。</p><h2 id="play-framework-技术栈">Play! Framework 技术栈</h2><p><img src="../assets/img/play-stack.png" alt="Image of play stack" /></p><p>从上图可以看到 <code class="highlighter-rouge">Play!</code> 是一个全栈（full-stack）式 Web 框架，它提供了诸如开发、测试、发布等一系列工具以及插件的支持。接下来我们就 <code class="highlighter-rouge">Play!</code> 的几个比较突出的特点进行介绍。</p><h2 id="开发效率高">开发效率高</h2><p><img src="../assets/img/play-java-layer.png" alt="Image of play and java layer" /></p><p>通过上图可以对比一下 <code class="highlighter-rouge">Play!</code> 与传统的 <code class="highlighter-rouge">Java EE</code> 框架的区别，可以看到 <code class="highlighter-rouge">Play!</code> 在架构上更加清晰简洁。在 <code class="highlighter-rouge">Play!</code>之前， 相比于 <a href="https://en.wikipedia.org/wiki/Ruby_on_Rails">ROR （Ruby on Rails）</a>风格的框架，传统的 Java Web 框架在开发网页应用的时候往往耗时比较长，原因主要有两个：</p><p>1、依赖 <code class="highlighter-rouge">Servlet</code></p><p>传统的 Java Web 框架都是基于 <code class="highlighter-rouge">Servlet</code> 来构建的，开发人员开发的应用也需要在 <code class="highlighter-rouge">Servlet</code> 容器中运行，但是这就带来了一个后果，开发人员每次修改完代码之后，都需要重新启动 Web 服务器才能看到修改后的效果。如果某一个项目规模较小，那重启以及编译的时间还能接受，但是如果项目很大，那开发过程中所花的大部分时间都浪费在重启以及编译上面了。</p><p>通过上图可以看到， <code class="highlighter-rouge">Play!</code> 抛弃了 <code class="highlighter-rouge">Servlet</code>，基于 <code class="highlighter-rouge">Netty</code> 实现了自己的 HTTP Server，解决了修改代码需要重启服务器的问题。当开发人员修改完代码之后，只需要刷新一下浏览器就可以看到修改之后的效果，从而提高了开发效率。</p><p>2、 复杂的 <code class="highlighter-rouge">XML</code> 配置文件</p><p>传统的 Java Web 框架在开发某个 Web 应用的时候需要引入大量的 XML 配置文件，这些文件在配置起来比较麻烦，如果数量很多且分散在不同的文件下面会使得维护成本增加。</p><p><code class="highlighter-rouge">Play!</code> 框架深谙 <code class="highlighter-rouge">ROR</code> 之道，采用 <code class="highlighter-rouge">约定优于配置</code>，只有一个全局的配置文件 <code class="highlighter-rouge">application.conf</code>，其他大部分配置都是默认的，我们只需要按照它约定的去做好了。</p><h2 id="无状态stateless">无状态（Stateless）</h2><p><code class="highlighter-rouge">Play!</code> 框架抛弃了 Servlet/JSP 里 Session 等概念，在每次 HTTP Request 之间不会在 Server 端存储状态，所需的状态都需要在 HTTP Request 之间传递，这样做的好处就是使得服务器的水平扩展性增强了，比如，当系统流量过大时，我们只需要新增一个节点就可以立即增加系统的负载能力。</p><h2 id="restful">RESTFul</h2><p>传统的 Java Web 框架利用 Servlet 将 Http协议隐藏了起来，也就是说开发者不能很直观地看到某一个请求对应的某个操作。而 <code class="highlighter-rouge">Play!</code> 在设计上拥抱了 Http 协议，比如我们要获取一个用户列表，我们就可以在 <code class="highlighter-rouge">route</code> 文件中这样写：</p><div class="highlighter-rouge"><pre class="highlight"><code>GET      /customer/list      controllers.CustomerController.list
</code></pre></div><p>那么 <code class="highlighter-rouge">/customer/list</code> 这个 URL 对应的就是 <code class="highlighter-rouge">CustomerController</code> 中的 <code class="highlighter-rouge">list</code> 方法。</p><p>这样看上去更加直观。</p><h2 id="异步非阻塞">异步非阻塞</h2><p>由于 <code class="highlighter-rouge">Play!</code> 的 HTTP Server 是基于 <code class="highlighter-rouge">Netty</code> 实现的， 而<code class="highlighter-rouge">Netty</code> 具有异步高性能、高可靠性和高成熟度的优点，而且 <code class="highlighter-rouge">Play!</code> 的默认配置已经为 <code class="highlighter-rouge">controller</code> 做了优化，所以本质上，<code class="highlighter-rouge">Play!</code> 从里到外都是异步的。<code class="highlighter-rouge">Play!</code> 能够以异步，非阻塞方式处理每一个请求。另外 <code class="highlighter-rouge">Play!</code> 的最新版本 <code class="highlighter-rouge">Play 2.6.x</code> ，其 HTTP Server 是基于 <code class="highlighter-rouge">Akka HTTP</code> 实现的，也能很好地支持异步非阻塞。 <code class="highlighter-rouge">Play!</code> 通过放弃传统 Java Web 框架中的 <code class="highlighter-rouge">Servlet</code> 而采用自己实现的 HTTP Server，使得它在开发高性能 Web 应用时具有很大的优势。</p><h2 id="强类型模板">强类型模板</h2><p>从 <code class="highlighter-rouge">Play! 2</code> 开始， <code class="highlighter-rouge">Play!</code> 的模板就全面拥抱了 <code class="highlighter-rouge">Scala</code>，所以 <code class="highlighter-rouge">Play!</code> 的模板都是可以编译的 Scala 函数，这就意味着我们可以在编译的时候直接在浏览器或者控制台中看到模板的错误信息，而不用等到将应用部署，调用页面之后才能发现错误。</p></article><div class="page-navigation"> <a class="home" href="/" title="Back to Homepage">Home</a> <span> &middot; </span> <a class="prev" href="/notes/performance-in-collection" title="PREV: 如何在 Scala 中科学地操作 collection（二）：集合性能比较">&gt;&gt;</a></div></main><div class="footer"> <!-- 多说评论框 start --><div class="ds-thread" data-thread-key="Play! Framework 系列（一）：初探 play 框架" data-title="Play! Framework 系列（一）：初探 play 框架" data-url="http://shawdubie.com/notes/Play! Framework 系列（一）：初探 play 框架"></div><!-- 多说评论框 end --> · <span class="block">Made with &hearts; using <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> &amp; <a href="https://github.com/heiswayi/the-plain" title="The Plain theme by Heiswayi Nrird" target="_blank">The Plain</a> &middot; &lt;/&gt; on <a href="https://github.com/Shonrain" title="Hosted on GitHub" target="_blank">GitHub</a></span> <span class="block">&copy; 2017 ShawDubie</span></div></body></html>