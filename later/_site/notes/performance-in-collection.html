<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>如何在 Scala 中科学地操作 collection（二）：集合性能比较</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@HeiswayiNrird" /><meta name="twitter:title" content="如何在 Scala 中科学地操作 collection（二）：集合性能比较" /><meta name="twitter:description" content="在平时使用集合的时候，我们经常会选择 Scala 中通用的集合，例如：Seq、Map、List等等，有的时候选择「通用集合」完全可以解决问题，但是当集合操作变得很复杂以至于涉及到「性能问题」的时候，采用「通用集合」可能并不是一个好的选择。在不同的场景下选择合适的集合可以使我们对于集合的操作更加高效。"><meta name="description" content="在平时使用集合的时候，我们经常会选择 Scala 中通用的集合，例如：Seq、Map、List等等，有的时候选择「通用集合」完全可以解决问题，但是当集合操作变得很复杂以至于涉及到「性能问题」的时候，采用「通用集合」可能并不是一个好的选择。在不同的场景下选择合适的集合可以使我们对于集合的操作更加高效。"> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?2db4617ae1e0a3147b448ffe9d4a4c26"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><style> /* latin-ext */ @font-face { font-family: 'Karla'; font-style: normal; font-weight: 400; src: local('Karla'), local('Karla-Regular'), url(https://fonts.gstatic.com/s/karla/v5/S1bXQ0LrY7AzefpgNae9sYDGDUGfDkXyfkzVDelzfFk.woff2) format('woff2'); unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF; } /* latin */ @font-face { font-family: 'Karla'; font-style: normal; font-weight: 400; src: local('Karla'), local('Karla-Regular'), url(https://fonts.gstatic.com/s/karla/v5/JaMH4jmmzP070-OYo03anaCWcynf_cDxXwCLxiixG1c.woff2) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215; }</style><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/notes/performance-in-collection"><link rel="alternate" type="application/atom+xml" title="ShawDubie" href="/feed.xml" /> <!-- 多说公共JS代码 start (一个网页只需插入一次) --> <script type="text/javascript"> var duoshuoQuery = {short_name:"shawdubie"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); </script> <!-- 多说公共JS代码 end --></head><body><aside class="logo"> <a href="/"> <img src="../assets/img/shaw.jpeg" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>如何在 Scala 中科学地操作 collection（二）：集合性能比较</h1><time>May 2, 2017</time></div><div class="divider"></div><p>在平时使用集合的时候，我们经常会选择 Scala 中通用的集合，例如：<code class="highlighter-rouge">Seq</code>、<code class="highlighter-rouge">Map</code>、<code class="highlighter-rouge">List</code>等等，有的时候选择「通用集合」完全可以解决问题，但是当集合操作变得很复杂以至于涉及到「性能问题」的时候，采用「通用集合」可能并不是一个好的选择。在不同的场景下选择合适的集合可以使我们对于集合的操作更加高效。</p><p>大部分情况下，我们都会优先采用「不可变集合」，所以本文将通过比较几种常见的「不可变集合」来阐述各个集合之间的性能差异。</p><h2 id="set">Set</h2><p><img src="../assets/img/set.png" alt="Image of Set" /></p><p>通过上图可以看到，两种常用的类型：<code class="highlighter-rouge">TreeSet</code>、<code class="highlighter-rouge">HashSet</code> 都继承至 <code class="highlighter-rouge">Set</code>。</p><h3 id="treeset">TreeSet</h3><p><code class="highlighter-rouge">TreeSet</code> 是用「红黑树」来实现的，「红黑树」是一种相对平衡的二叉查找树，它可以在 <code class="highlighter-rouge">O(log2 n)</code> 时间复杂度内做查找，例如：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">TreeSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>
</code></pre></div><p>则其对应的红黑树为：</p><p><img src="../assets/img/red-black-tree.png" alt="image of redBlackTree" /></p><p>从上面「红黑树」的结构可以看到在对 <code class="highlighter-rouge">TreeSet</code> 进行查找或者修改操作时，其时间复杂度为 <code class="highlighter-rouge">O(log2 n)</code>。</p><h3 id="hashset">HashSet</h3><p><code class="highlighter-rouge">HashSet</code> 是用 <code class="highlighter-rouge">Hash Trie</code> 来实现的，从表现形式上可以将 <code class="highlighter-rouge">HashSet</code> 看作是一种树结构，该树的每个节点包含32个元素或者32个子树，每个节点都存储相应的 <code class="highlighter-rouge">hashcode</code> ，为了方便描述这种结构我们先定义一个 <code class="highlighter-rouge">HashSet</code> 的实例，并将该实例用图表现出来：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">289</span><span class="o">,</span> <span class="mi">306</span><span class="o">,</span> <span class="mi">1057</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">289</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1057</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">306</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="mi">50</span><span class="o">)</span>
</code></pre></div><p>看到上面的代码，我们或许会有一个疑问，就是得到的 <code class="highlighter-rouge">HashSet</code> 中各个元素的顺序好像变了，这是因为在实现 <code class="highlighter-rouge">HashSet</code> 时，元素的顺序不是按照我们给定的顺序来的，而是根据元素对应的 <code class="highlighter-rouge">hashcode</code> 来决定的，在 <code class="highlighter-rouge">HashSet</code> 中，元素的 <code class="highlighter-rouge">hashcode</code>是通过下面的操作得到的：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code>
<span class="k">def</span> <span class="n">getHashCode</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">hcode</span> <span class="k">=</span> <span class="n">key</span><span class="o">.#</span><span class="k">#</span>
    <span class="k">var</span> <span class="n">h</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">hcode</span> <span class="o">+</span> <span class="o">~(</span><span class="n">hcode</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="o">)</span>
    <span class="n">h</span> <span class="k">=</span> <span class="n">h</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">14</span><span class="o">)</span>
    <span class="n">h</span> <span class="k">=</span> <span class="n">h</span> <span class="o">+</span> <span class="o">(</span><span class="n">h</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">)</span>
    <span class="n">h</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">10</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div><p>为了方便理解，我们这里规定元素的 <code class="highlighter-rouge">hashcode</code> 就是它本身，那么之前的代码就变成了：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">289</span><span class="o">,</span> <span class="mi">306</span><span class="o">,</span> <span class="mi">1057</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">1057</span><span class="o">,</span> <span class="mi">289</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">306</span><span class="o">)</span>
</code></pre></div><p>其对应的树结构为： <img src="../assets/img/hash-set.png" alt="image of hashSet" /></p><p>通过上图，我们可以看到「树」的每个节点都存储相应的 <code class="highlighter-rouge">hashcode</code>，在这棵「树」上查找某个值时，首先用该元素对应的 <code class="highlighter-rouge">hashcode</code> 的最后 <code class="highlighter-rouge">5</code> 个 <code class="highlighter-rouge">bit</code> 查找第一层「子树」，然后毎 <code class="highlighter-rouge">5</code> 个 <code class="highlighter-rouge">bit</code> 找到下一层 「子树」。当存储在一个节点中所有元素的代表他们当前所在层的 <code class="highlighter-rouge">hashcode</code> 位都不相同时，查找结束。例如：</p><p>如果我们要查找数字 <code class="highlighter-rouge">1057</code> 是否在这棵「树」上面：</p><ol><li><p>将 <code class="highlighter-rouge">1057</code> 转换为 「二进制」，我们得到 <code class="highlighter-rouge">00001 00001 00001</code>，然后取出最后的 <code class="highlighter-rouge">5</code> 个 <code class="highlighter-rouge">bit</code>：<code class="highlighter-rouge">00001</code>；</p></li><li><p>查找第一层「子树」，找到 <code class="highlighter-rouge">00001</code> 对应的节点，该节点有三个「孩子」，所以我们要进入下一层，接下来取出第二个「五位」：<code class="highlighter-rouge">00001</code>；</p></li><li><p>查找第二层「子树」，找到 <code class="highlighter-rouge">00001</code> 对应的节点，该节点有两个「孩子」，所以我们要进入下一层，接下来取出第三个「五位」：<code class="highlighter-rouge">00001</code>；</p></li><li><p>查找第三层「子树」，找到 <code class="highlighter-rouge">00001</code> 对应的节点，该节点就只有一个元素 <code class="highlighter-rouge">1057</code>，所以我们找到了。</p></li></ol><p>在这棵树中，我们查询 <code class="highlighter-rouge">1057</code> 的时间复杂度为 <code class="highlighter-rouge">O(3)</code>，由于 <code class="highlighter-rouge">Hashset</code> 中的每一个节点都可以有 <code class="highlighter-rouge">32</code> 个分支，所以其在查询或者修改等操作时的效率会大大提高，例如：对于一个拥有100万个元素的 <code class="highlighter-rouge">HashSet</code>，我们只需要四层节点。（因为10<sup>6</sup> ≈ 32<sup>4</sup>），我们在查询其中的某一个元素时，最多只需要 <code class="highlighter-rouge">O(4)</code> 的时间复杂度，而采用 <code class="highlighter-rouge">TreeSet</code> 就需要 <code class="highlighter-rouge">O(20)</code> 的时间复杂度，所以在不出现「哈希碰撞」的情况下（在日常开发中使用 <code class="highlighter-rouge">HashSet</code> 极少会出现「哈希碰撞」），<code class="highlighter-rouge">HashSet</code> 的随机访问时间复杂度为 <code class="highlighter-rouge">log32 n</code>，比前面介绍的 <code class="highlighter-rouge">TreeSet</code> 要好。</p><h3 id="总结">总结</h3><p>通过前面我们对两种 <code class="highlighter-rouge">Set</code> 的比较，我们可以得出：</p><ol><li><p>当集合中元素不是很多，而且对效率要求不高的时候，选择通用的 <code class="highlighter-rouge">Set</code> 就可以解决问题；</p></li><li><p>当元素数量非常庞大，并且对效率要求比较高的时候，我们一般选择 <code class="highlighter-rouge">HashSet</code>；</p></li><li><p>当选择 <code class="highlighter-rouge">HashSet</code> 时，出现很严重的 「哈希碰撞」时，采用 <code class="highlighter-rouge">TreeSet</code>。</p></li></ol><h2 id="map">Map</h2><p><img src="../assets/img/map.png" alt="Image of Map" /></p><p>如上图所示，<code class="highlighter-rouge">Map</code> 支持三种类型：<code class="highlighter-rouge">HashMap</code>、<code class="highlighter-rouge">TreeMap</code> 和 <code class="highlighter-rouge">ListMap</code>，其中比较常用的是前面两种。</p><h3 id="hashmaptreemap">HashMap、TreeMap</h3><p><code class="highlighter-rouge">HashMap</code> 与我们前面提到的 <code class="highlighter-rouge">HashSet</code> 结构类似，同样，<code class="highlighter-rouge">TreeMap</code> 与 <code class="highlighter-rouge">TreeSet</code> 结构类似，一般情况下，优先选择 <code class="highlighter-rouge">HashMap</code>。</p><h3 id="listmap">ListMap</h3><p><code class="highlighter-rouge">ListMap</code> 是一种「链表」结构，在对其中的元素进行操作的时候，我们通常都会去遍历其中的元素，所以其查询、修改等操作的时间复杂度也同列表长度成「线性关系」，一般情况下，在 <code class="highlighter-rouge">Scala</code> 中，我们很少使用 <code class="highlighter-rouge">ListMap</code>，只有当 <code class="highlighter-rouge">Map</code> 中处在前面的元素的访问频率远远大于处在后面的元素时，才会采用 <code class="highlighter-rouge">ListMap</code>。</p><h3 id="总结-1">总结</h3><ol><li><p>当集合中元素不是很多，而且对效率要求不高的时候，选择通用的 <code class="highlighter-rouge">Map</code> 就可以解决问题</p></li><li><p>当元素数量非常庞大，并且对效率要求比较高的时候，我们一般选择 <code class="highlighter-rouge">HashMap</code>；</p></li><li><p>当选择 <code class="highlighter-rouge">HashSet</code> 时，出现很严重的 「哈希碰撞」时，采用 <code class="highlighter-rouge">TreeMap</code>；</p></li><li><p>当 <code class="highlighter-rouge">Map</code> 中处在前面的元素的访问频率远远大于处在后面的元素时，采用 <code class="highlighter-rouge">ListMap</code>。</p></li></ol><h2 id="seq">Seq</h2><p><img src="../assets/img/seq.png" alt="Image of Seq" /></p><p>通过上图可以看到，两种常用的类型：<code class="highlighter-rouge">Vector</code>、<code class="highlighter-rouge">List</code> 都继承至 <code class="highlighter-rouge">Seq</code></p><h3 id="vector">Vector</h3><p><code class="highlighter-rouge">Vector</code> 的结构与我们前面提到的 <code class="highlighter-rouge">HashSet</code> 非常的类似，我们可以将 <code class="highlighter-rouge">Vector</code> 看成是由元素的「下标」组成的「前缀树」，该树的每个节点也包含32个元素或者32个子树，每个节点存储相应下标对应的元素以及具有相同「前缀」的「孩子」，为了方便描述，我们依然先定义一个 <code class="highlighter-rouge">Vector</code> 的实例：</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">1057</span><span class="o">).</span><span class="n">toVector</span>
<span class="n">v</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">...</span> <span class="o">,</span> <span class="mi">1057</span><span class="o">)</span>
</code></pre></div><p>我们定义了一个具有 <code class="highlighter-rouge">1058</code> 个元素的 <code class="highlighter-rouge">Vector</code>，每一个元素的下标与该元素的值相等。接下来我们用图将该实例表现出来：</p><p><img src="../assets/img/vector-trie.png" alt="Image of vector trie" /></p><p>上图展示了实例中的部分元素，可以看到具有相同「前缀」的元素拥有相同的「父亲」，例如：</p><p>元素 <code class="highlighter-rouge">33</code>、<code class="highlighter-rouge">35</code>、<code class="highlighter-rouge">50</code>对应的「二进制」分别是：<code class="highlighter-rouge">00001 00001</code>、<code class="highlighter-rouge">00001 00011</code>、<code class="highlighter-rouge">00001 10010</code>，它们的「高五位」也就是「前缀」都是 <code class="highlighter-rouge">00001</code>。</p><p>现在我们查找其中的某个元素 <code class="highlighter-rouge">1057</code>：</p><ol><li><p><code class="highlighter-rouge">1057</code> 对应的下标是 <code class="highlighter-rouge">1057</code>，转换为二进制为：<code class="highlighter-rouge">00001 00001 00001</code>；</p></li><li><p><code class="highlighter-rouge">1057</code> 最高五位也就是第一个前缀为 <code class="highlighter-rouge">00001</code>，在第一层「子树」中找到 <code class="highlighter-rouge">00001</code> 对应的节点；</p></li><li><p>第二个五位也就是第二个 「前缀」是 <code class="highlighter-rouge">00001</code>，则在第二层「子树」中找到 <code class="highlighter-rouge">00001</code> 对应的节点；</p></li><li><p>最后一个五位是 <code class="highlighter-rouge">00001</code>，在第三层子树中找到 <code class="highlighter-rouge">00001</code> 对应的节点，则该元素存在于这个节点中。</p></li></ol><p>可以看到我们查询 <code class="highlighter-rouge">1057</code> 的时间复杂度为：<code class="highlighter-rouge">O(3)</code>，由于 <code class="highlighter-rouge">Vector</code> 也是采用具有 <code class="highlighter-rouge">32</code> 分支的树结构，所以它的查询、修改等操作的时间复杂度也是 <code class="highlighter-rouge">log32 n</code>，由于下标不会重复，所以不会像 <code class="highlighter-rouge">HashSet</code> 那样出现 「哈希碰撞」，所以它的效率比 <code class="highlighter-rouge">HashSet</code> 要好。</p><p>在 <code class="highlighter-rouge">Scala</code> 中使用集合的时候，如果没有特别的要求，我们应该首先选择 <code class="highlighter-rouge">Vector</code>。当然，<code class="highlighter-rouge">vector</code> 也有不适用的场景，如果我们要频繁地执行一个集合的「头」和「尾」的操作，选择 <code class="highlighter-rouge">Vector</code> 就不太好了，这时我们可以选择 <code class="highlighter-rouge">List</code>。</p><h3 id="list">List</h3><p>在日常开发中我们使用 <code class="highlighter-rouge">List</code> 的频率非常高，<code class="highlighter-rouge">List</code> 是个 「单链表」结构，其中的每个节点都可以看作是一个「格子」，每一个「格子」持有两个引用，一个引用指向值，另一个引用指向后续的元素。</p><div class="language-scala highlighter-rouge"><pre class="highlight"><code>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div><p>其结构用图表示出来为：</p><p><img src="../assets/img/list.png" alt="Image of list" /></p><p><code class="highlighter-rouge">List</code> 只有在操作 「头部」和「尾部」时具有 <code class="highlighter-rouge">O(1)</code> 的复杂度，如果列表中的元素非常多，那 <code class="highlighter-rouge">List</code> 的效率远远不如前面提到的 <code class="highlighter-rouge">Vector</code>，所以只有当我们需要频繁操作集合中的首尾元素时，才去选择 <code class="highlighter-rouge">List</code>，大部分情况下， <code class="highlighter-rouge">Vector</code> 应该是我们缺省的选择。</p><h3 id="总结-2">总结</h3><ol><li><p>一般情况下，优先采用 <code class="highlighter-rouge">Vector</code>；</p></li><li><p>只有在头尾操作非常频繁的时候选择 <code class="highlighter-rouge">List</code>。</p></li></ol></article><div class="page-navigation"> <a class="next" href="/notes/first-glance-at-play" title="NEXT: Play! Framework 系列（一）：初探 play 框架">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="/" title="Back to Homepage">Home</a> <span> &middot; </span> <a class="prev" href="/notes/How-to-use-algebraic-data-type-in-development" title="PREV: 如何在 Scala 中利用 ADT 良好地组织业务">&gt;&gt;</a></div></main><div class="footer"> <!-- 多说评论框 start --><div class="ds-thread" data-thread-key="如何在 Scala 中科学地操作 collection（二）：集合性能比较" data-title="如何在 Scala 中科学地操作 collection（二）：集合性能比较" data-url="http://shawdubie.com/notes/如何在 Scala 中科学地操作 collection（二）：集合性能比较"></div><!-- 多说评论框 end --> · <span class="block">Made with &hearts; using <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> &amp; <a href="https://github.com/heiswayi/the-plain" title="The Plain theme by Heiswayi Nrird" target="_blank">The Plain</a> &middot; &lt;/&gt; on <a href="https://github.com/Shonrain" title="Hosted on GitHub" target="_blank">GitHub</a></span> <span class="block">&copy; 2020 ShawDubie</span></div></body></html>